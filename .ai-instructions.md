# AI Instructions — service-helpe-rs

This document describes the conventions and rules to follow when contributing to this codebase.

## Project Overview

`service-helpe-rs` is an opinionated Rust helper library used by headless services at Scoop.it. It provides reusable building blocks: configuration loading, error formatting, JWT validation, HTTP metrics, tracing, and framework-specific middleware for **axum** and **warp**.

This is a **library crate** (no `main.rs`). It is published on a private Cargo registry (`cargo-hosted`), not on crates.io.

## Tooling

- **Rust edition**: 2021
- **Task runner**: `just` (see `justfile`)
- **Tests**: `cargo test --all-features`
- **Release**: Managed via `cargo workspaces version` + `cargo publish --registry cargo-hosted`

## Feature Flags

Functionality is gated behind Cargo **feature flags**. Every optional dependency is declared with `dep:` syntax and tied to a feature. When adding a new module that depends on optional crates:

1. Declare a feature in `Cargo.toml` listing its required optional dependencies.
2. Guard the module declaration in `src/lib.rs` with `#[cfg(feature = "...")]`.
3. Guard any cross-feature code (e.g. `tokio`-dependent helpers) with `#[cfg(feature = "...")]`.

Existing features: `tracing-gelf`, `metrics`, `tokio`, `warp`, `axum`, `tracing`, `jwt`.  
No features are enabled by default (`default = []`).

## Code Organisation

```
src/
  lib.rs              # Root: module declarations, ServiceDef struct
  config.rs           # Configuration loading (YAML / env)
  errors.rs           # Shared error formatting utilities
  jwt.rs              # JWT validation + framework-specific sub-modules (inline)
  metrics.rs          # Prometheus helpers (counters, gauges, metrics endpoint)
  tracing_gelf.rs     # GELF tracing initialisation
  axum/               # Axum-specific middleware & error types
    mod.rs
    error.rs
    metrics.rs
    options.rs
    tracing_access_log.rs
  warp/               # Warp-specific filters & error types
    mod.rs
    error.rs
    metrics.rs
```

Rules:
- **One concern per file.** Each file owns a single, cohesive piece of functionality.
- **Framework-specific code** lives under its own directory (`axum/`, `warp/`). Shared logic stays at the top level.
- When a framework sub-module is small and tightly coupled (e.g. JWT + warp filter), it may live as an **inline sub-module** inside the parent file (see `jwt.rs` → `pub mod warp { … }`).
- Use `mod.rs` inside directories for module declarations and re-exports (`pub use`).

## Error Handling

- Use **`anyhow::Result`** as the return type for fallible functions.
- Add context to errors with **`.context("…")`** or **`.with_context(|| format!(…))`** (prefer the latter when the message includes runtime data to avoid unnecessary allocations on the happy path).
- Define domain-specific error types with **`thiserror::Error`** derive when they carry semantic meaning that callers need to match on (e.g. `NotFound`, `BadRequest`, `Forbidden`).
- In HTTP handlers, use **`anyhow::Error::downcast`** chains to map domain errors to HTTP status codes, and fall back to 500 with a log for unknown errors.
- Format full error chains for logging with the `format_error` helper from `errors.rs`.

## Logging

- Use the **`log`** crate (`log::error!`, `log::warn!`, `log::debug!`, …) as the default logging facade in non-tracing modules.
- Use the **`tracing`** crate only in modules that explicitly depend on the `tracing` feature (e.g. `tracing_access_log.rs`).
- Log at **`warn`** level for expected-but-notable events (e.g. unauthorized requests, empty key files).
- Log at **`error`** level for unexpected failures in request handling.

## Documentation

- All **public items** (functions, structs, enums, traits, modules) must have `///` doc comments.
- Use Markdown formatting in doc comments: backticks for code, code blocks for examples.
- Reference related crates or features when appropriate (e.g. `/// Requires the \`warp\` feature.`).
- Keep comments factual and concise—describe *what* and *why*, not *how* (the code shows how).

## Coding Style

### General
- Follow standard **`rustfmt`** formatting (no custom `.rustfmt.toml`).
- Prefer **implicit returns** (no trailing `return` unless for early exit).
- Use **early returns** with `?` to keep the happy path left-aligned.
- Use **`let … else`** for unwrapping with early return on failure.
- Prefer **`const fn`** for constructors when all operations are const-compatible.
- Use **generics with trait bounds** (e.g. `C: DeserializeOwned`) to keep APIs flexible.

### Naming
- **snake_case** for functions, methods, variables, modules.
- **PascalCase** for types (structs, enums, traits).
- **SCREAMING_SNAKE_CASE** for statics and constants.
- Test function names describe the scenario: `validate_valid_token_with_kid`, `load_from_file_invalid_yaml`.

### Imports
- Group imports: `std` first, then external crates, then `crate::` / `super::`.
- Use **specific imports** (`use serde::de::DeserializeOwned`) rather than glob imports.
- Prefer `use crate::…` for internal cross-module references.

### Lifetimes & Ownership
- Prefer borrowing (`&str`, `&ServiceDef`) over owning when the function does not need ownership.
- Use explicit lifetime annotations when structs hold references (e.g. `ServiceDef<'a>`).

## Testing

- Tests go in a **`#[cfg(test)] mod tests { … }`** block at the bottom of the file they test.
- Use **`tempfile`** (dev dependency) for any test that needs filesystem fixtures.
- Cover both **success and error paths**. For error cases, assert on `is_err()` and, when useful, assert that the error message contains an expected substring.
- Helpers private to tests (e.g. `create_keys_yaml`, `make_token`) are defined inside the `mod tests` block.
- Test names are descriptive and follow the pattern `<action>_<scenario>` (e.g. `load_from_file_with_valid_key`, `validate_missing_bearer_prefix`).

## Dependencies

- Pin dependencies with **caret ranges** (`^1.0`) or **minor ranges** (`"0.9"`) — avoid exact pinning unless necessary.
- Mark dependencies **optional** when they are only needed behind a feature flag.
- Keep the dependency tree lean: do not add a dependency for trivial functionality.

## Axum / Warp Middleware Patterns

### Axum
- Middleware signature: `async fn(req: Request, next: Next) -> impl IntoResponse`.
- Use `lazy_static!` for global Prometheus metric instances.
- Skip recording metrics/logs for `/metrics` and `/health` endpoints.

### Warp
- Use `warp::Filter` combinators to compose request processing.
- Custom rejections implement `warp::reject::Reject`.
- Warp-specific metrics use `warp::log::custom` closures.

## Configuration

- Configuration structs derive `Deserialize` (and `Serialize` when needed).
- Support loading from **YAML file** (`serde_yaml`) and/or **environment variables** (`envy`).
- Use the `LoadConfigMode` enum to clearly express the loading strategy.
- Default config file path follows the pattern `/etc/{pkg_name}/config.yaml`.
